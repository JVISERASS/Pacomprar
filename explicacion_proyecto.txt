===== EXPLICACIÓN DEL PROYECTO PACOMPRAR - GUÍA PARA LA DEFENSA =====

=== 1. ESTRUCTURA GENERAL DEL PROYECTO ===

El proyecto PaComprar es una plataforma de subastas online desarrollada con Next.js (React), que permite a los usuarios crear subastas, pujar por productos, gestionar su perfil y más. La aplicación está organizada siguiendo una arquitectura cliente-servidor, donde:

- Frontend: Next.js (React)
- Backend: API REST externa (https://pacomprarserver.onrender.com/api)
- Persistencia de datos: Gestionada por el backend

La estructura del proyecto sigue un patrón modular y orientado a componentes:
- /app: Estructura de páginas de Next.js (enrutamiento basado en archivos)
- /components: Componentes reutilizables
- /config: Configuraciones centralizadas
- /contexts: Contextos de React (para estado global)
- /hooks: Hooks personalizados de React
- /services: Servicios para comunicación con APIs
- /public: Archivos estáticos

=== 2. SISTEMA DE AUTENTICACIÓN Y AUTORIZACIÓN ===

El sistema de autenticación está implementado mediante JWT (JSON Web Tokens) y se compone de tres partes principales:

1. AuthContext (contexts/AuthContext.jsx):
   - Proporciona un contexto global de autenticación a toda la aplicación
   - Mantiene el estado del usuario autenticado
   - Proporciona métodos para login/logout y gestión de perfil
   - Utiliza localStorage para persistir la sesión

2. useAuthFetch (hooks/useAuthFetch.js):
   - Hook personalizado para realizar peticiones HTTP autenticadas
   - Añade automáticamente el token de autenticación a las cabeceras
   - Maneja automáticamente respuestas 401 (Unauthorized)
   - Gestiona errores y estados de carga

3. auth.service.js (services/auth.service.js):
   - Servicio para operaciones de bajo nivel de autenticación
   - Maneja tokens JWT (decodificación, validación)
   - Contiene lógica para refresh tokens y verificación de expiración

Flujo de autenticación:
1. Usuario introduce credenciales en la página de login
2. AuthContext realiza petición a la API y obtiene tokens JWT
3. Los tokens se almacenan en localStorage y el estado de usuario se actualiza
4. El hook useAuthFetch utiliza estos tokens para realizar peticiones autenticadas

=== 3. GESTIÓN DE LLAMADAS A LA API ===

Todas las URLs de la API están centralizadas en un único archivo (config/apiConfig.js), lo que permite:
- Cambiar rápidamente entre diferentes backends (desarrollo, producción, etc.)
- Mantener consistencia en las rutas utilizadas
- Documentar los endpoints disponibles

Para añadir una nueva llamada a la API:
1. Definir la ruta en apiConfig.js:
   ```javascript
   NUEVA_RUTA: getApiUrl('nuevo-endpoint/'),
   RUTA_CON_PARAM: (id) => getApiUrl(`recurso/${id}/accion/`),
   ```

2. Utilizar useAuthFetch para realizar la petición autenticada:
   ```javascript
   const { authFetch } = useAuthFetch();
   
   // GET request
   const datos = await authFetch(API_ROUTES.NUEVA_RUTA);
   
   // POST request
   const respuesta = await authFetch(API_ROUTES.NUEVA_RUTA, {
     method: 'POST',
     body: JSON.stringify(nuevosDatos)
   });
   ```

=== 4. SISTEMA DE SUBASTAS ===

El core de la aplicación es el sistema de subastas, que incluye:

1. Listado de subastas (app/subastas/SubastasContent.jsx):
   - Muestra todas las subastas disponibles
   - Implementa filtros por categoría, precio y búsqueda
   - Utiliza paginación para rendimiento

2. Detalle de subasta (app/subastas/[id]/page.jsx):
   - Muestra información completa de una subasta
   - Permite realizar pujas
   - Incluye sistema de comentarios y valoraciones
   - Muestra historial de pujas

3. Crear/editar subasta (app/subastas/crear/ y app/subastas/[id]/editar/):
   - Formularios para crear y editar subastas
   - Validación de datos
   - Subida de imágenes

4. Gestión de pujas (app/usuario/mis_pujas/):
   - Listado de pujas realizadas por el usuario
   - Funcionalidad para cancelar pujas
   - Actualización en tiempo real

=== 5. PÁGINA PRINCIPAL Y NAVEGACIÓN ===

- Layout principal (app/layout.jsx): Define la estructura común a todas las páginas
- Navbar (components/Navbar/Navbar.jsx): Menú de navegación con estado de autenticación
- Footer (components/Footer/Footer.jsx): Pie de página común

La navegación utiliza el enrutador de Next.js, que ofrece:
- Enrutamiento basado en sistema de archivos
- Navegación del lado del cliente sin recargas
- Rutas dinámicas con parámetros ([id])

=== 6. COMPONENTES REUTILIZABLES ===

La aplicación utiliza varios componentes reutilizables:

- AuctionItem: Tarjeta para mostrar una subasta en listados
- StarRating: Sistema de valoración con estrellas
- Comments: Sistema de comentarios
- EditBidModal: Modal para editar una puja
- PasswordChangeForm: Formulario para cambiar contraseña

=== 7. POSIBLES PREGUNTAS Y RESPUESTAS PARA EL EXAMEN ===

P: ¿Cómo implementarías un nuevo filtro en el listado de subastas?
R: En SubastasContent.jsx, añadiría:
   1. Un nuevo campo en el estado 'filters'
   2. Un control en el JSX para que el usuario seleccione el filtro
   3. Añadiría el nuevo parámetro a la construcción de queryParams
   4. Actualizaría updateUrlWithFilters para incluir el nuevo filtro

P: ¿Cómo añadirías una nueva característica como "subastas favoritas"?
R: 
   1. Añadiría un nuevo endpoint en apiConfig.js:
      ```
      FAVORITE_AUCTIONS: getApiUrl('favoritas/'),
      TOGGLE_FAVORITE: (id) => getApiUrl(`subastas/${id}/favorito/`),
      ```
   2. Crearía un botón para marcar/desmarcar favoritos en AuctionItem
   3. Implementaría una función toggleFavorite usando authFetch
   4. Crearía una nueva página para mostrar las subastas favoritas

P: ¿Cómo manejas los errores en las peticiones a la API?
R: Uso un enfoque de múltiples capas:
   1. useAuthFetch captura errores HTTP y de autenticación
   2. Cada componente implementa bloques try/catch para errores específicos
   3. Se muestra feedback visual al usuario mediante estados de error
   4. Los errores se muestran en la interfaz de usuario de forma amigable

P: ¿Cómo mejorarías el rendimiento de la aplicación?
R:
   1. Implementando memorización (useMemo, useCallback) para cálculos costosos
   2. Virtualizando listas largas para renderizar solo elementos visibles
   3. Implementando carga lazy de imágenes (ya uso el componente Image de Next.js)
   4. Utilizando SSR (Server Side Rendering) para la carga inicial de datos
   5. Implementando una estrategia de caché para consultas frecuentes

P: ¿Cómo implementarías notificaciones en tiempo real cuando alguien supere tu puja?
R:
   1. Implementaría una conexión WebSocket o utilizaría Server-Sent Events
   2. Crearía un hook personalizado (useNotifications) que mantenga la conexión
   3. Añadiría un componente NotificationCenter en el layout principal
   4. Mostraría notificaciones toast cuando lleguen nuevos eventos

=== 8. CONCEPTOS IMPORTANTES A CONOCER ===

1. React y sus Hooks principales:
   - useState: Gestión de estado local
   - useEffect: Manejo de efectos secundarios (llamadas API, suscripciones)
   - useContext: Consumo de contextos (como AuthContext)
   - useCallback/useMemo: Optimización de rendimiento

2. Next.js y su enrutamiento:
   - Routing basado en sistema de archivos
   - Rutas dinámicas con [parámetros]
   - Navegación programática con useRouter()
   - Layouts compartidos

3. JWT como sistema de autenticación:
   - Estructura de un token JWT (header.payload.signature)
   - Ventajas sobre sistemas basados en sesión
   - Seguridad y buenas prácticas (almacenamiento, refresh tokens)

4. Comunicación con APIs REST:
   - Métodos HTTP (GET, POST, PUT, DELETE)
   - Códigos de estado HTTP y su manejo
   - Autenticación mediante Bearer token
   - Formatos de intercambio de datos (JSON)

5. Patrón de Arquitectura:
   - Componentes presentacionales vs. contenedores
   - Gestión de estado global (Context API)
   - Separación de responsabilidades (componentes, servicios, hooks)

=== 9. POSIBLES MEJORAS O EXTENSIONES DEL PROYECTO ===

1. Implementación de pruebas:
   - Pruebas unitarias con Jest/React Testing Library
   - Pruebas de integración para flujos completos
   - Pruebas end-to-end con Cypress o Playwright

2. Características adicionales:
   - Sistema de notificaciones en tiempo real
   - Chat integrado entre compradores y vendedores
   - Sistema de pagos para completar compras
   - Historial detallado de transacciones

3. Optimizaciones técnicas:
   - Implementar Server Components de Next.js
   - Mejorar SEO con metadatos dinámicos
   - Progressive Web App (PWA) para uso offline
   - Optimización de imágenes y lazy loading

4. UX/Accesibilidad:
   - Modo oscuro / Temas personalizados
   - Soporte para lectores de pantalla y navegación por teclado
   - Diseño responsive mejorado
   - Animaciones y transiciones para mejor feedback

=== 10. FLUJO DE TRABAJO PARA IMPLEMENTAR NUEVAS FUNCIONALIDADES ===

1. Definición de la nueva ruta en apiConfig.js
2. Creación de componentes necesarios
3. Implementación de la lógica de negocio
4. Integración con el sistema de autenticación usando useAuthFetch
5. Testing manual y ajustes finales
6. Despliegue de los cambios

=== 11. ARQUITECTURA DE LA APLICACIÓN ===

La aplicación sigue una arquitectura basada en componentes con gestión de estado centralizada:

- Capa de presentación: Components de React y páginas
- Capa de lógica de negocio: Hooks personalizados y servicios
- Capa de datos: API REST externa
- Estado global: Context API (AuthContext)
- Navegación: Next.js Router

Este enfoque permite una clara separación de responsabilidades y facilita el mantenimiento y la evolución del código.

=== CONCLUSIÓN ===

Este proyecto demuestra conocimientos sólidos de desarrollo frontend moderno con React/Next.js, implementación de autenticación segura, interacción con APIs y diseño de interfaces de usuario. La estructura modular y la separación de responsabilidades facilitan tanto el mantenimiento como la ampliación de funcionalidades.

Durante la defensa, recuerda enfatizar no solo lo que has implementado, sino también por qué has tomado ciertas decisiones técnicas y cómo contribuyen a la calidad general del software.